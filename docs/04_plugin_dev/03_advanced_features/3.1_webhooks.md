---
title: Webhook æ¥å…¥ç‚¹ï¼ˆå·²åºŸå¼ƒï¼‰
description: Webhook åŠŸèƒ½å·²åºŸå¼ƒï¼Œè¯·ä½¿ç”¨æ–°çš„åŠ¨æ€è·¯ç”±åŠŸèƒ½ã€‚æœ¬æ–‡æ¡£ä¿ç•™ç”¨äºå…¼å®¹æ€§å‚è€ƒã€‚
---

# Webhook æ¥å…¥ç‚¹ï¼ˆå·²åºŸå¼ƒï¼‰

::: danger åŠŸèƒ½å·²åºŸå¼ƒ
Webhook åŠŸèƒ½å·²è¢«æ ‡è®°ä¸ºåºŸå¼ƒï¼Œå°†åœ¨æœªæ¥ç‰ˆæœ¬ä¸­ç§»é™¤ã€‚è¯·ä½¿ç”¨æ–°çš„ [åŠ¨æ€è·¯ç”±åŠŸèƒ½](./3.4_dynamic_router.md) æ¥å®ç°å¤–éƒ¨ HTTP æ¥å…¥ç‚¹ã€‚åŠ¨æ€è·¯ç”±æä¾›äº†æ›´å¼ºå¤§ã€æ›´çµæ´»çš„ Web API å¼€å‘èƒ½åŠ›ã€‚
:::

::: warning è¿ç§»å»ºè®®
å¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨ Webhook åŠŸèƒ½ï¼Œå»ºè®®å°½å¿«è¿ç§»åˆ°åŠ¨æ€è·¯ç”±ï¼š

- Webhook â†’ åŠ¨æ€è·¯ç”±çš„ RESTful API ç«¯ç‚¹
- æ›´å¥½çš„è¯·æ±‚å¤„ç†å’Œå“åº”ç®¡ç†
- æ”¯æŒå®Œæ•´çš„ FastAPI åŠŸèƒ½
- æ›´è§„èŒƒçš„ API è®¾è®¡æ¨¡å¼
  :::

## åºŸå¼ƒåŸå› 

Webhook åŠŸèƒ½è¢«åºŸå¼ƒçš„ä¸»è¦åŸå› ï¼š

1. **åŠŸèƒ½é‡å **ï¼šåŠ¨æ€è·¯ç”±æä¾›äº†æ›´å®Œæ•´çš„ Web API å¼€å‘èƒ½åŠ›
2. **è®¾è®¡å±€é™**ï¼šWebhook è®¾è®¡ç›¸å¯¹ç®€å•ï¼Œæ— æ³•æ»¡è¶³å¤æ‚çš„ API éœ€æ±‚
3. **ç»´æŠ¤æˆæœ¬**ï¼šåŠ¨æ€è·¯ç”±ç»Ÿä¸€äº† HTTP æ¥å…¥ç‚¹çš„å®ç°æ–¹å¼

## åŸæœ‰åŠŸèƒ½æ¦‚è¿°

~~Webhook å…è®¸ä½ çš„ Nekro Agent æ’ä»¶æ¥æ”¶æ¥è‡ªå¤–éƒ¨ç³»ç»Ÿï¼ˆå¦‚ GitHub, GitLab, CI/CD å·¥å…·, IoT è®¾å¤‡, è‡ªå®šä¹‰æœåŠ¡ç­‰ï¼‰çš„å®æ—¶ HTTP æ¨é€é€šçŸ¥ã€‚è¿™ä½¿å¾—æ’ä»¶èƒ½å¤Ÿå“åº”å¤–éƒ¨äº‹ä»¶ï¼Œä¾‹å¦‚ä»£ç æäº¤ã€ç›‘æ§å‘Šè­¦ã€æ•°æ®æ›´æ–°ç­‰ï¼Œå¹¶è§¦å‘ Agent å†…çš„ç›¸åº”æ“ä½œï¼Œå¦‚å‘é€æ¶ˆæ¯ã€æ›´æ–°æ•°æ®æˆ–è°ƒç”¨å…¶ä»–æ’ä»¶åŠŸèƒ½ã€‚~~

## Webhook åŸºç¡€

å½“å¤–éƒ¨ç³»ç»Ÿå‘ç”Ÿç‰¹å®šäº‹ä»¶æ—¶ï¼Œå®ƒä¼šå‘é¢„å…ˆé…ç½®å¥½çš„ URLï¼ˆå³æ’ä»¶æä¾›çš„ Webhook æ¥å…¥ç‚¹ï¼‰å‘é€ä¸€ä¸ª HTTP è¯·æ±‚ï¼ˆé€šå¸¸æ˜¯ POST è¯·æ±‚ï¼Œä½†ä¹Ÿæ”¯æŒ GET ç­‰å…¶ä»–æ–¹æ³•ï¼‰ã€‚æ’ä»¶çš„ Webhook å¤„ç†å™¨æ¥æ”¶è¿™ä¸ªè¯·æ±‚ï¼Œè§£æå…¶å†…å®¹ï¼ˆé€šå¸¸æ˜¯ JSON æˆ–è¡¨å•æ•°æ®ï¼‰ï¼Œç„¶åæ‰§è¡Œç›¸åº”çš„é€»è¾‘ã€‚

## æ³¨å†Œ Webhook

æ’ä»¶é€šè¿‡ `@plugin.mount_webhook_method()` è£…é¥°å™¨æ³¨å†Œä¸€ä¸ªå¼‚æ­¥å‡½æ•°ä½œä¸º Webhook å¤„ç†å™¨ã€‚è¿™ä¸ªè£…é¥°å™¨ä¼šå°†è¯¥å‡½æ•°ä¸ä¸€ä¸ªç‰¹å®šçš„ HTTP è·¯å¾„å…³è”èµ·æ¥ã€‚

```python
from fastapi import Request, HTTPException # FastAPI ç”¨äºå¤„ç† HTTP è¯·æ±‚
from nekro_agent.api import core, message, context # Agent API
import hmac
import hashlib
import json

# å‡è®¾ plugin å®ä¾‹å·²å®šä¹‰

@plugin.mount_webhook_method(
    endpoint="/github", # ç›¸å¯¹äºæ’ä»¶ Webhook æ ¹è·¯å¾„çš„ç«¯ç‚¹
    name="GitHub Webhook Handler",
    description="æ¥æ”¶å¹¶å¤„ç†æ¥è‡ª GitHub çš„ Webhook äº‹ä»¶ã€‚"
)
async def handle_github_webhook(request: Request):
    """å¤„ç† GitHub Webhook è¯·æ±‚ã€‚

    éªŒè¯ç­¾åï¼Œè§£æ payloadï¼Œå¹¶æ ¹æ®äº‹ä»¶ç±»å‹é‡‡å–è¡ŒåŠ¨ã€‚
    """
    core.logger.info(f"æ’ä»¶ '{plugin.name}' æ”¶åˆ° GitHub Webhook è¯·æ±‚ã€‚")

    # 1. å®‰å…¨éªŒè¯ (æ¨è)
    github_signature = request.headers.get("X-Hub-Signature-256")
    if not github_signature:
        core.logger.warning("Webhook è¯·æ±‚ç¼ºå°‘ X-Hub-Signature-256 å¤´éƒ¨ã€‚")
        raise HTTPException(status_code=400, detail="Missing signature")

    # ä»æ’ä»¶é…ç½®ä¸­è·å– Webhook ç§˜å¯† (secret)
    webhook_secret = plugin.config.GITHUB_WEBHOOK_SECRET # å‡è®¾é…ç½®é¡¹å­˜åœ¨
    if not webhook_secret:
        core.logger.error("GitHub Webhook secret æœªåœ¨æ’ä»¶é…ç½®ä¸­è®¾ç½®ï¼")
        raise HTTPException(status_code=500, detail="Webhook secret not configured")

    request_body = await request.body()
    if not verify_github_signature(request_body, webhook_secret, github_signature):
        core.logger.warning("Webhook ç­¾åéªŒè¯å¤±è´¥ï¼")
        raise HTTPException(status_code=403, detail="Invalid signature")

    # 2. è§£æ Payload
    try:
        payload = await request.json() # æˆ–è€… request.form() å–å†³äºå¤–éƒ¨ç³»ç»Ÿå‘é€çš„ Content-Type
    except json.JSONDecodeError:
        core.logger.warning("Webhook è¯·æ±‚ä½“ä¸æ˜¯æœ‰æ•ˆçš„ JSONã€‚")
        raise HTTPException(status_code=400, detail="Invalid JSON payload")

    # 3. å¤„ç†äº‹ä»¶
    event_type = request.headers.get("X-GitHub-Event")
    core.logger.info(f"å·²éªŒè¯çš„ GitHub äº‹ä»¶: {event_type}")

    if event_type == "push":
        repo_name = payload.get("repository", {}).get("full_name", "æœªçŸ¥ä»“åº“")
        pusher_name = payload.get("pusher", {}).get("name", "æœªçŸ¥æ¨é€è€…")
        commits = payload.get("commits", [])
        commit_count = len(commits)

        notification_message = (
            f"ğŸ“¦ ä»£ç æ¨é€äº‹ä»¶\n"
            f"ä»“åº“: {repo_name}\n"
            f"æ¨é€è€…: {pusher_name}\n"
            f"æäº¤æ•°: {commit_count}\n"
        )
        if commits:
            latest_commit_message = commits[0].get("message", "æ— æäº¤ä¿¡æ¯")
            notification_message += f"æœ€æ–°æäº¤: {latest_commit_message.splitlines()[0]}"

        # å‡è®¾æ’ä»¶é…ç½®äº†é€šçŸ¥çš„ç›®æ ‡ä¼šè¯
        target_chat_key = plugin.config.NOTIFICATION_CHAT_KEY
        if target_chat_key:
            _ctx = await context.create_temp_ctx(target_chat_key) # åˆ›å»ºä¸´æ—¶ä¸Šä¸‹æ–‡ç”¨äºå‘æ¶ˆæ¯
            await message.send_text(target_chat_key, notification_message, _ctx)
            core.logger.info(f"å·²å‘ {target_chat_key} å‘é€ GitHub æ¨é€é€šçŸ¥ã€‚")
        else:
            core.logger.warning("æœªé…ç½® GitHub é€šçŸ¥çš„ç›®æ ‡ä¼šè¯ (NOTIFICATION_CHAT_KEY)ã€‚")

    elif event_type == "issues":
        # å¤„ç† issues äº‹ä»¶...
        pass

    # 4. è¿”å›å“åº”
    # é€šå¸¸ï¼ŒWebhook å¤„ç†å™¨åº”å¿«é€Ÿè¿”å› 2xx å“åº”ï¼Œè¡¨ç¤ºå·²æ”¶åˆ°äº‹ä»¶ã€‚
    # è€—æ—¶æ“ä½œåº”å¼‚æ­¥å¤„ç†ã€‚
    return {"status": "success", "message": f"Event '{event_type}' received and acknowledged."}


def verify_github_signature(payload_body: bytes, secret: str, signature_header: str) -> bool:
    """éªŒè¯ GitHub Webhook ç­¾å"""
    if not signature_header.startswith("sha256="):
        return False
    expected_signature = signature_header[7:] # ç§»é™¤ "sha256=" å‰ç¼€

    hashed_payload = hmac.new(secret.encode('utf-8'), payload_body, hashlib.sha256).hexdigest()
    return hmac.compare_digest(hashed_payload, expected_signature)

```

**è£…é¥°å™¨å‚æ•°ï¼š**

- `endpoint` (str): Webhook çš„è·¯å¾„ï¼Œç›¸å¯¹äºæ’ä»¶çš„ Webhook æ ¹ URLã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ’ä»¶åä¸º `my_plugin`ï¼ŒAgent è¿è¡Œåœ¨ `http://localhost:8000`ï¼Œæ­¤å¤„çš„ `endpoint` ä¸º `"/github"`ï¼Œåˆ™å®Œæ•´çš„ Webhook URL å°†æ˜¯ `http://localhost:8000/api/plugin/my_plugin/webhook/github`ã€‚
- `name` (str, å¯é€‰): Webhook çš„å¯è¯»åç§°ï¼Œç”¨äºæ—¥å¿—æˆ–ç®¡ç†ç•Œé¢ã€‚
- `description` (str, å¯é€‰): Webhook åŠŸèƒ½çš„ç®€çŸ­æè¿°ã€‚

**Webhook å¤„ç†å™¨ (`async def` å‡½æ•°):**

- å¿…é¡»æ˜¯å¼‚æ­¥å‡½æ•°ã€‚
- æ¥æ”¶ä¸€ä¸ª `fastapi.Request` å¯¹è±¡ä½œä¸ºå‚æ•°ï¼Œå¯ä»¥ä»ä¸­è·å–è¯·æ±‚å¤´ã€è¯·æ±‚ä½“ã€æŸ¥è¯¢å‚æ•°ç­‰ã€‚
- é€šå¸¸éœ€è¦è¿›è¡Œå®‰å…¨éªŒè¯ï¼ˆå¦‚æ£€æŸ¥ç­¾åã€æ¥æº IP ç­‰ï¼‰ã€‚
- è§£æè¯·æ±‚ä½“ï¼ˆå¦‚ JSONã€è¡¨å•æ•°æ®ï¼‰ã€‚
- æ ¹æ®è§£æçš„æ•°æ®æ‰§è¡Œä¸šåŠ¡é€»è¾‘ã€‚
- **å¿«é€Ÿå“åº”**ï¼šWebhook å¤„ç†å™¨åº”å°½å¿«è¿”å› HTTP å“åº”ï¼ˆé€šå¸¸æ˜¯ `200 OK` æˆ–å…¶ä»– `2xx` çŠ¶æ€ç ï¼‰ï¼Œä»¥å‘ŠçŸ¥å¤–éƒ¨ç³»ç»Ÿäº‹ä»¶å·²æˆåŠŸæ¥æ”¶ã€‚ä»»ä½•è€—æ—¶çš„æ“ä½œéƒ½åº”è¯¥åœ¨åå°å¼‚æ­¥æ‰§è¡Œï¼Œé¿å…é˜»å¡ Webhook å“åº”å¯¼è‡´å¤–éƒ¨ç³»ç»Ÿè¶…æ—¶é‡è¯•ã€‚
- å¯ä»¥ä½¿ç”¨ `fastapi.HTTPException` æ¥è¿”å›æ ‡å‡†çš„ HTTP é”™è¯¯å“åº”ã€‚

## Webhook URL ç»“æ„

æ’ä»¶ Webhook çš„å®Œæ•´ URL ç»“æ„é€šå¸¸å¦‚ä¸‹ï¼š

`{BASE_URL}/api/plugin/{plugin_author}.{plugin_module_name}/webhook{endpoint}`

- `{BASE_URL}`: Nekro Agent çš„åŸºç¡€ URL (ä¾‹å¦‚ `http://localhost:8080`)ã€‚
- `{plugin_author}.{plugin_module_name}`: æ’ä»¶çš„å”¯ä¸€é”®ï¼Œç”±ä½œè€…å’Œæ¨¡å—åç»„æˆã€‚
- `{endpoint}`: åœ¨ `@plugin.mount_webhook_method()` ä¸­å®šä¹‰çš„ `endpoint` å‚æ•°ï¼Œå¿…é¡»ä»¥ `/` å¼€å¤´ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœæ’ä»¶ä½œè€…æ˜¯ `dev`ï¼Œæ¨¡å—åæ˜¯ `sample_webhook`ï¼Œ`endpoint` æ˜¯ `/myevent`ï¼Œåˆ™ URL å¯èƒ½æ˜¯ï¼š
`http://localhost:8080/api/plugin/dev.sample_webhook/webhook/myevent`

å»ºè®®åœ¨æ’ä»¶çš„ `README.md` æˆ–é…ç½®è¯´æ˜ä¸­æ¸…æ™°åœ°åˆ—å‡ºå…¶æä¾›çš„æ‰€æœ‰ Webhook URLã€‚

## å®‰å…¨éªŒè¯

ç”±äº Webhook æ¥å…¥ç‚¹æš´éœ²åœ¨å…¬ç½‘ä¸Šï¼Œå› æ­¤å®æ–½å®‰å…¨éªŒè¯è‡³å…³é‡è¦ï¼Œä»¥ç¡®ä¿è¯·æ±‚æ¥è‡ªå¯ä¿¡çš„æºå¹¶é˜²æ­¢æ¶æ„æ”»å‡»ã€‚

å¸¸è§çš„éªŒè¯æ–¹æ³•ï¼š

1.  **ç­¾åéªŒè¯ (æ¨è)**ï¼š
    - å¤–éƒ¨ç³»ç»Ÿä½¿ç”¨ä¸€ä¸ªå…±äº«çš„ç§˜å¯† (Secret) å¯¹è¯·æ±‚ä½“ (Payload) è¿›è¡Œå“ˆå¸Œç­¾å (å¦‚ HMAC-SHA256)ã€‚
    - ç­¾åç»“æœé€šè¿‡ç‰¹å®šçš„è¯·æ±‚å¤´ (å¦‚ `X-Hub-Signature-256` for GitHub, `X-Gitlab-Token` for GitLab) å‘é€ã€‚
    - æ’ä»¶ç«¯ä½¿ç”¨ç›¸åŒçš„ç§˜å¯†å’Œç®—æ³•é‡æ–°è®¡ç®—ç­¾åï¼Œå¹¶ä¸è¯·æ±‚å¤´ä¸­çš„ç­¾åè¿›è¡Œæ¯”è¾ƒã€‚
    - å¦‚ä¸Šä¾‹ `verify_github_signature` å‡½æ•°æ‰€ç¤ºã€‚
    - ç§˜å¯†åº”å­˜å‚¨åœ¨æ’ä»¶çš„é…ç½®ä¸­ (æ ‡è®°ä¸º `is_secret`)ï¼Œç»ä¸èƒ½ç¡¬ç¼–ç åœ¨ä»£ç é‡Œã€‚
2.  **IP åœ°å€ç™½åå•**ï¼š
    - å¦‚æœå¤–éƒ¨ç³»ç»Ÿçš„å‡ºå£ IP åœ°å€å›ºå®šæˆ–åœ¨å·²çŸ¥èŒƒå›´å†…ï¼Œå¯ä»¥åœ¨æ’ä»¶æˆ–ç½‘å…³å±‚é¢é…ç½® IP ç™½åå•ã€‚
    - ä½† IP åœ°å€å¯èƒ½å˜åŒ–ï¼Œç»´æŠ¤æˆæœ¬è¾ƒé«˜ã€‚
3.  **è®¤è¯ä»¤ç‰Œ**ï¼š
    - è¦æ±‚å¤–éƒ¨ç³»ç»Ÿåœ¨è¯·æ±‚å¤´æˆ–æŸ¥è¯¢å‚æ•°ä¸­æºå¸¦ä¸€ä¸ªé¢„å…±äº«çš„è®¤è¯ä»¤ç‰Œã€‚
    - ç›¸å¯¹ç®€å•ï¼Œä½†å®‰å…¨æ€§ä¸å¦‚ç­¾åéªŒè¯ï¼Œå› ä¸ºä»¤ç‰Œå¯èƒ½æ³„éœ²ã€‚

**åŠ¡å¿…å®æ–½è‡³å°‘ä¸€ç§æœ‰æ•ˆçš„å®‰å…¨éªŒè¯æœºåˆ¶ã€‚**

## å¤„ç†ä¸åŒ HTTP æ–¹æ³•

é»˜è®¤æƒ…å†µä¸‹ï¼ŒWebhook å¤„ç†å™¨å¯ä»¥å“åº”æ‰€æœ‰ HTTP æ–¹æ³•ã€‚å¦‚æœéœ€è¦é’ˆå¯¹ç‰¹å®šæ–¹æ³•ï¼ˆå¦‚ `GET`, `PUT`, `DELETE`ï¼‰è¿›è¡Œå¤„ç†ï¼Œå¯ä»¥åœ¨å¤„ç†å™¨å†…éƒ¨æ£€æŸ¥ `request.method`ï¼š

```python
@plugin.mount_webhook_method(endpoint="/resource", name="Resource Handler")
async def handle_resource(request: Request):
    if request.method == "GET":
        # å¤„ç† GET è¯·æ±‚ï¼Œä¾‹å¦‚è¿”å›èµ„æºçŠ¶æ€
        return {"status": "available", "data": await get_resource_data()}
    elif request.method == "POST":
        # å¤„ç† POST è¯·æ±‚ï¼Œä¾‹å¦‚åˆ›å»ºæ–°èµ„æº
        payload = await request.json()
        resource_id = await create_resource(payload)
        return {"status": "created", "id": resource_id}, 201 # è¿”å› 201 Created
    elif request.method == "DELETE":
        # å¤„ç† DELETE è¯·æ±‚ï¼Œä¾‹å¦‚åˆ é™¤èµ„æº
        # ...
        return {"status": "deleted"}
    else:
        raise HTTPException(status_code=405, detail="Method Not Allowed")
```

## ä» Webhook å‘ä¼šè¯å‘é€é€šçŸ¥

Webhook çš„ä¸€ä¸ªå¸¸è§ç”¨é€”æ˜¯å°†å¤–éƒ¨äº‹ä»¶é€šçŸ¥ç»™ Nekro Agent å†…çš„ç‰¹å®šç”¨æˆ·æˆ–ä¼šè¯ã€‚

```python
from nekro_agent.api import message, context

async def notify_chat(chat_key: str, notification_text: str):
    if not chat_key:
        core.logger.warning("æ— æ³•å‘é€ Webhook é€šçŸ¥ï¼šç›®æ ‡ chat_key ä¸ºç©ºã€‚")
        return

    try:
        # ä¸ºå‘é€æ¶ˆæ¯åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ AgentCtx
        # æ³¨æ„ï¼šè¿™ä¸ªä¸´æ—¶ä¸Šä¸‹æ–‡å¯èƒ½ä¸åŒ…å«å®Œæ•´çš„ç”¨æˆ·æˆ–ä¼šè¯ä¿¡æ¯ï¼Œä»…ç”¨äºæ¶ˆæ¯å‘é€
        _ctx = await context.create_temp_ctx(chat_key=chat_key)

        await message.send_text(chat_key, notification_text, _ctx)
        core.logger.info(f"Webhook é€šçŸ¥å·²å‘é€è‡³ {chat_key}ã€‚")
    except Exception as e:
        core.logger.error(f"é€šè¿‡ Webhook å‘é€é€šçŸ¥è‡³ {chat_key} å¤±è´¥: {e}")

# åœ¨ä½ çš„ Webhook å¤„ç†å™¨ä¸­è°ƒç”¨ï¼š
# target_chat = plugin.config.TARGET_CHAT_FOR_ALERTS
# await notify_chat(target_chat, "ç´§æ€¥å‘Šè­¦ï¼šæœåŠ¡å™¨ CPU ä½¿ç”¨ç‡è¶…è¿‡ 90%ï¼")
```

ç›®æ ‡ä¼šè¯ `chat_key` é€šå¸¸åº”ä»æ’ä»¶çš„é…ç½®ä¸­è·å–ï¼Œå…è®¸ç”¨æˆ·æŒ‡å®šæ¥æ”¶é€šçŸ¥çš„ç¾¤ç»„æˆ–ç§èŠã€‚

## å¤„ç†æ–‡ä»¶ä¸Šä¼ 

Webhook ä¹Ÿå¯ä»¥ç”¨äºæ¥æ”¶æ–‡ä»¶ä¸Šä¼ ã€‚FastAPI æä¾›äº†å¤„ç† `multipart/form-data` è¯·æ±‚çš„èƒ½åŠ›ã€‚

```python
from fastapi import File, UploadFile, Form

@plugin.mount_webhook_method(endpoint="/upload_report", name="Upload Report")
async def handle_report_upload(
    request: Request,
    report_file: UploadFile = File(...), # "report_file" æ˜¯è¡¨å•å­—æ®µå
    report_name: str = Form(...),      # "report_name" ä¹Ÿæ˜¯è¡¨å•å­—æ®µå
    target_chat: str = Form(...)
):
    core.logger.info(f"æ”¶åˆ°æ–‡ä»¶ä¸Šä¼ : {report_file.filename} (ç±»å‹: {report_file.content_type})ï¼ŒæŠ¥å‘Šåç§°: {report_name}")

    # éªŒè¯æ–‡ä»¶ç±»å‹ã€å¤§å°ç­‰ (æ¨è)
    if not report_file.content_type.startswith("text/"):
        raise HTTPException(status_code=400, detail="ä»…æ”¯æŒæ–‡æœ¬æ–‡ä»¶ä¸Šä¼ ã€‚")

    # è¯»å–æ–‡ä»¶å†…å®¹
    contents = await report_file.read() # bytes
    report_text = contents.decode('utf-8')

    # å¤„ç†æ–‡ä»¶å†…å®¹ï¼Œä¾‹å¦‚ä¿å­˜åˆ°æ’ä»¶ç›®å½•æˆ–å‘é€ç»™ç”¨æˆ·
    # plugin_data_path = plugin.get_plugin_path() / "uploads"
    # plugin_data_path.mkdir(exist_ok=True)
    # async with aiofiles.open(plugin_data_path / report_file.filename, "wb") as f:
    #     await f.write(contents)

    await notify_chat(target_chat, f"æ”¶åˆ°æ–°çš„æŠ¥å‘Š '{report_name}' ({report_file.filename})ã€‚å†…å®¹æ‘˜è¦ï¼š\n{report_text[:200]}...")

    return {"status": "success", "filename": report_file.filename, "size": len(contents)}
```

## å¼‚æ­¥ä»»åŠ¡å¤„ç† (é‡è¦)

è™½ç„¶ FastAPI ä¼šå¼‚æ­¥æ‰§è¡Œï¼ˆ`await`ï¼‰ä½ çš„ `async def` Webhook å¤„ç†å™¨ï¼Œä½†è¿™ä»…è¡¨ç¤ºå¤„ç†å™¨æœ¬èº«ä¸ä¼šé˜»å¡æœåŠ¡å™¨çš„å…¶ä»–æ“ä½œã€‚HTTP å®¢æˆ·ç«¯ä»ç„¶ä¼šç­‰å¾…å¤„ç†å™¨å®Œæˆå…¶æ‰€æœ‰å†…éƒ¨æ“ä½œï¼ˆåŒ…æ‹¬ `await` çš„éƒ¨åˆ†ï¼‰åæ‰èƒ½æ”¶åˆ°å“åº”ã€‚
å› æ­¤ï¼Œå¦‚æœ Webhook å¤„ç†å™¨å†…éƒ¨åŒ…å«**ä¸åº”å»¶è¿Ÿå¯¹å¤–éƒ¨ç³»ç»Ÿå“åº”çš„è€—æ—¶æ“ä½œ**ï¼ˆä¾‹å¦‚ï¼Œè°ƒç”¨å¤šä¸ªå¤–éƒ¨ APIã€å¤„ç†å¤§å‹æ•°æ®ã€å¤æ‚çš„è®¡ç®—ä»»åŠ¡ï¼‰ï¼Œåˆ™**å¼ºçƒˆå»ºè®®å°†è¿™äº›ç‰¹å®šæ“ä½œæ”¾åˆ°åå°ä»»åŠ¡ä¸­æ‰§è¡Œ**ã€‚è¿™èƒ½ç¡®ä¿æ’ä»¶å¿«é€Ÿå‘å¤–éƒ¨ç³»ç»Ÿç¡®è®¤æ”¶åˆ° Webhookï¼ˆä¾‹å¦‚è¿”å› `202 Accepted`ï¼‰ï¼Œè€Œå®é™…çš„å¤„ç†åœ¨åå°è¿›è¡Œã€‚

Python çš„ `asyncio.create_task()` æˆ–ç±»ä¼¼æœºåˆ¶ï¼ˆå¦‚ Celery, RQ ç­‰ï¼Œå¦‚æœé¡¹ç›®é›†æˆï¼‰å¯ç”¨äºæ­¤ç›®çš„ã€‚

```python
import asyncio

async def long_running_process(data: dict, chat_to_notify: str):
    core.logger.info(f"å¼€å§‹å¤„ç†è€—æ—¶ä»»åŠ¡: {data.get('task_id')}")
    await asyncio.sleep(10) # æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
    result_message = f"ä»»åŠ¡ {data.get('task_id')} å¤„ç†å®Œæˆã€‚ç»“æœæ˜¯ï¼šXXXX"
    await notify_chat(chat_to_notify, result_message)
    core.logger.info(f"è€—æ—¶ä»»åŠ¡ {data.get('task_id')} å®Œæˆå¹¶å·²é€šçŸ¥ã€‚")

@plugin.mount_webhook_method(endpoint="/start_job", name="Start Long Job")
async def start_job_webhook(request: Request):
    payload = await request.json()
    task_id = payload.get("task_id", "unknown_task")
    chat_key = payload.get("notify_chat_key") # å‡è®¾ payload åŒ…å«é€šçŸ¥ç›®æ ‡

    if not chat_key:
        return {"status": "error", "message": "notify_chat_key æœªæä¾›"}, 400

    # åˆ›å»ºå¹¶å¯åŠ¨åå°ä»»åŠ¡ï¼Œä¸ç­‰å¾…å…¶å®Œæˆ
    asyncio.create_task(long_running_process({"task_id": task_id, **payload}, chat_key))

    core.logger.info(f"å·²ä¸ºä»»åŠ¡ {task_id} åˆ›å»ºåå°å¤„ç†ç¨‹åºã€‚")
    return {"status": "accepted", "task_id": task_id, "message": "ä½œä¸šå·²æ¥æ”¶å¹¶æ­£åœ¨åå°å¤„ç†ã€‚"}, 202 # è¿”å› 202 Accepted
```

é€šè¿‡åˆç†ä½¿ç”¨ Webhookï¼Œä½ çš„æ’ä»¶å¯ä»¥æå¤§åœ°æ‰©å±• Nekro Agent ä¸å¤–éƒ¨ä¸–ç•Œçš„è¿æ¥èƒ½åŠ›ã€‚
