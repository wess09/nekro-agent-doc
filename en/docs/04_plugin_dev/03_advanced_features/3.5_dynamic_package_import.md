---
title: 动态包导入
description: 学习如何在 Nekro Agent 插件中使用动态包导入功能，在运行时按需安装和导入 Python 包，扩展插件的功能边界
---

# 动态包导入

Nekro Agent 提供了动态包导入功能，允许插件在运行时按需安装和导入 Python 第三方包。这个特性让插件能够在不修改系统环境的前提下，灵活地使用各种 Python 生态中的工具库和框架。

## 功能概述

动态包导入功能具备以下特点：

- **按需安装**：只在需要时才下载和安装包，节省系统资源
- **版本控制**：支持精确的版本规范和依赖约束
- **隔离存储**：包安装在插件专属目录，不影响系统 Python 环境
- **镜像支持**：支持配置 PyPI 镜像源，加速国内下载
- **错误处理**：提供友好的错误提示和异常处理机制

## 基础用法

### 导入函数

从 `nekro_agent.api.plugin` 导入动态包导入函数：

```python
from nekro_agent.api.plugin import dynamic_import_pkg
from nekro_agent.api.schemas import AgentCtx
```

### 简单导入示例

最简单的用法是直接提供包名：

```python
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "use_requests", "使用 requests 库发送 HTTP 请求")
async def fetch_url(_ctx: AgentCtx, url: str) -> str:
    """使用动态导入的 requests 库获取网页内容"""

    # 动态导入 requests 包
    requests = dynamic_import_pkg("requests")

    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        return f"成功获取页面，状态码: {response.status_code}，内容长度: {len(response.text)} 字符"
    except Exception as e:
        return f"请求失败: {e}"
```

## 版本规范

### 指定版本范围

支持标准的 Python 包版本规范语法：

```python
# 精确版本
pandas = dynamic_import_pkg("pandas==2.0.0")

# 最低版本要求
numpy = dynamic_import_pkg("numpy>=1.24.0")

# 版本范围
requests = dynamic_import_pkg("requests>=2.25.0,<3.0.0")

# 排除特定版本
flask = dynamic_import_pkg("flask>=2.0,!=2.0.1")
```

### 版本规范示例

```python
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "data_analysis", "执行数据分析")
async def analyze_data(_ctx: AgentCtx, data: list) -> str:
    """使用 pandas 进行数据分析"""

    # 导入特定版本的 pandas
    pd = dynamic_import_pkg(
        "pandas>=2.0.0,<3.0.0",
        import_name="pandas"  # 指定导入时的模块名
    )

    try:
        df = pd.DataFrame(data)
        summary = df.describe().to_string()
        return f"数据分析结果：\n{summary}"
    except Exception as e:
        return f"分析失败: {e}"
```

## 高级参数配置

### 完整参数说明

```python
dynamic_import_pkg(
    package_spec: str,                    # 包规范，如 "requests>=2.25.0"
    import_name: Optional[str] = None,    # 导入名称，默认使用包名
    mirror: Optional[str] = "https://pypi.tuna.tsinghua.edu.cn/simple",  # PyPI 镜像源
    trusted_host: bool = True,            # 是否信任镜像源主机
    timeout: int = 300,                   # 安装超时时间（秒）
    repo_dir: Optional[Path] = None       # 自定义安装目录
)
```

### 使用国内镜像加速

默认使用清华大学 PyPI 镜像源，也可以指定其他镜像：

```python
# 使用阿里云镜像
beautifulsoup4 = dynamic_import_pkg(
    "beautifulsoup4",
    mirror="https://mirrors.aliyun.com/pypi/simple/",
    trusted_host=True
)

# 使用腾讯云镜像
pillow = dynamic_import_pkg(
    "Pillow>=10.0.0",
    mirror="https://mirrors.cloud.tencent.com/pypi/simple",
    trusted_host=True
)

# 使用官方 PyPI（较慢）
scipy = dynamic_import_pkg(
    "scipy",
    mirror="https://pypi.org/simple",
    trusted_host=False
)
```

## 实用场景示例

### 示例 1：网页爬取

```python
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "scrape_webpage", "抓取网页内容")
async def scrape_webpage(_ctx: AgentCtx, url: str, selector: str) -> str:
    """使用 BeautifulSoup 抓取网页指定元素"""

    # 动态导入所需的包
    requests = dynamic_import_pkg("requests>=2.25.0")
    bs4 = dynamic_import_pkg("beautifulsoup4>=4.9.0", import_name="bs4")

    try:
        # 获取网页内容
        response = requests.get(url, timeout=10)
        response.raise_for_status()

        # 解析 HTML
        soup = bs4.BeautifulSoup(response.text, 'html.parser')
        elements = soup.select(selector)

        if not elements:
            return f"未找到匹配选择器 '{selector}' 的元素"

        # 提取文本内容
        results = [elem.get_text(strip=True) for elem in elements[:5]]  # 最多返回 5 个
        return f"找到 {len(elements)} 个元素，前 {len(results)} 个内容：\n" + "\n".join(results)

    except Exception as e:
        return f"抓取失败: {e}"
```

### 示例 2：图像处理

```python
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "process_image", "处理图像文件")
async def process_image(_ctx: AgentCtx, image_path: str, operation: str) -> str:
    """使用 Pillow 处理图像"""

    # 动态导入 Pillow
    PIL = dynamic_import_pkg("Pillow>=10.0.0", import_name="PIL")
    from PIL import Image, ImageFilter

    try:
        # 获取实际文件路径
        real_path = _ctx.fs.get_file(image_path)

        # 打开图像
        img = Image.open(real_path)

        # 根据操作类型处理
        if operation == "blur":
            processed = img.filter(ImageFilter.BLUR)
        elif operation == "grayscale":
            processed = img.convert('L')
        elif operation == "resize":
            processed = img.resize((800, 600))
        else:
            return f"不支持的操作: {operation}"

        # 保存处理后的图像
        output_path = _ctx.fs.shared_path / f"processed_{operation}.jpg"
        processed.save(output_path)

        # 返回给 AI 的沙盒路径
        sandbox_path = _ctx.fs.forward_file(output_path)
        return f"Image processing completed, result: {sandbox_path}"

    except Exception as e:
        return f"Image processing failed: {e}"
```

### Example 3: Data Processing and Visualization

```python
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "create_chart", "Create data chart")
async def create_data_chart(_ctx: AgentCtx, data: dict, chart_type: str) -> str:
    """Create data charts using matplotlib"""

    # Dynamically import data processing and visualization libraries
    pd = dynamic_import_pkg("pandas>=2.0.0", import_name="pandas")
    plt = dynamic_import_pkg("matplotlib>=3.5.0", import_name="matplotlib.pyplot")

    try:
        # Create DataFrame
        df = pd.DataFrame(data)

        # Create chart
        fig, ax = plt.subplots(figsize=(10, 6))

        if chart_type == "bar":
            df.plot(kind='bar', ax=ax)
        elif chart_type == "line":
            df.plot(kind='line', ax=ax)
        elif chart_type == "pie":
            df.plot(kind='pie', y=df.columns[0], ax=ax)
        else:
            return f"Unsupported chart type: {chart_type}"

        # Save chart
        output_path = _ctx.fs.shared_path / f"chart_{chart_type}.png"
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        plt.close(fig)

        # Return sandbox path
        sandbox_path = _ctx.fs.forward_file(output_path)
        return f"Chart generated: {sandbox_path}"

    except Exception as e:
        return f"Chart generation failed: {e}"
```

### Example 4: Scientific Computing

```python
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "scientific_compute", "Execute scientific computing")
async def scientific_compute(_ctx: AgentCtx, operation: str, values: list) -> str:
    """Perform scientific computing using NumPy and SciPy"""

    # Dynamically import scientific computing libraries
    np = dynamic_import_pkg("numpy>=1.24.0", import_name="numpy")
    scipy = dynamic_import_pkg("scipy>=1.10.0")

    try:
        data = np.array(values)

        if operation == "fft":
            # Fast Fourier Transform
            result = np.fft.fft(data)
            return f"FFT results (first 5): {result[:5]}"

        elif operation == "stats":
            # Statistical analysis
            from scipy import stats
            mean = np.mean(data)
            std = np.std(data)
            skew = stats.skew(data)
            kurtosis = stats.kurtosis(data)

            return f"""Statistical results:
- Mean: {mean:.4f}
- Standard deviation: {std:.4f}
- Skewness: {skew:.4f}
- Kurtosis: {kurtosis:.4f}"""

        elif operation == "interpolate":
            # Data interpolation
            from scipy import interpolate
            x = np.arange(len(data))
            f = interpolate.interp1d(x, data, kind='cubic')
            x_new = np.linspace(0, len(data)-1, len(data)*2)
            y_new = f(x_new)
            return f"Interpolation completed, original data points: {len(data)}, after interpolation: {len(y_new)}"

        else:
            return f"Unsupported operation: {operation}"

    except Exception as e:
        return f"Computation failed: {e}"
```

## Error Handling

Dynamic imports may fail due to network issues, non-existent packages, or other reasons

### Common Error Types

```python
# RuntimeError: Installation failed
# - Network connection problems
# - Package does not exist or version unavailable
# - SSL certificate verification failed
# - Mirror source access denied

# ImportError: Import failed
# - Package installed but module cannot be found
# - Import name does not match actual module name

# ValueError: Package specification format error
# - Incorrect version number format
# - Unsupported version operators used

# subprocess.TimeoutExpired: Installation timeout
# - Package size too large
# - Network speed too slow
```

## Considerations

### Security Considerations

1. **Only import trusted packages**: Only install packages from official PyPI or trusted mirror sources
2. **Version locking**: Use exact version numbers in production environments to avoid unexpected package updates
3. **Review dependencies**: Understand transitive dependencies of packages to avoid introducing unnecessary risks
4. **Document declaration**: Declare used packages in plugin documentation and note version numbers

### Performance Considerations

1. **First installation overhead**: The first time a package is used, there will be download and installation time
2. **Disk space**: Each package occupies disk space; be mindful of controlling the number and size of packages

### Compatibility Considerations

1. **Python version**: Ensure packages support the Python version running Nekro Agent
2. **System dependencies**: Some packages may require system-level dependency libraries (e.g., OpenCV requires specific C++ libraries)
3. **Package conflicts**: Be aware of potential dependency conflicts between different packages

## Troubleshooting

### Installation Succeeded but Import Failed

```
Error: ImportError: Installation succeeded but cannot import module_name

Solution:
1. Check if the import_name parameter is correct
2. Some packages have different import names than package names (e.g., Pillow -> PIL)
3. Package may require additional system dependencies
```

By properly utilizing the dynamic package import functionality, your plugin can flexibly leverage Python's rich ecosystem to implement more powerful and diverse features.
